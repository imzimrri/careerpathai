# Story 1.6: Implement Daytona Code Validation

- **Status:** Done

## Story

- **As a** career-changing developer,
- **I want** the generated code snippet to be validated in a secure sandbox environment,
- **so that** I can trust that the code is functional and safe to run.

## Acceptance Criteria

1. The backend can send the generated code snippet to Daytona for execution.
2. Daytona executes the code in a secure, isolated sandbox environment.
3. The backend receives a validation result (Success/Failure) from Daytona.
4. The validation result includes execution details (output, errors, execution time).
5. The validation result is integrated into the final career path response.
6. Error handling is implemented for Daytona API failures and execution timeouts.

## Tasks / Subtasks

- [ ] **Task 1 (AC: 1, 2):** Implement Daytona API integration.
  - [ ] Create function `validate_code_with_daytona(code: str, language: str)` in `api/daytona_client.py`
  - [ ] Configure Daytona API authentication and endpoints
  - [ ] Implement workspace creation and code execution
  - [ ] Implement workspace cleanup after execution
- [ ] **Task 2 (AC: 3, 4):** Parse and structure validation results.
  - [ ] Extract execution status (Success/Failure)
  - [ ] Capture stdout/stderr output
  - [ ] Capture execution time and resource usage
  - [ ] Handle execution timeouts
- [ ] **Task 3 (AC: 5):** Integrate validation into career path response.
  - [ ] Update `CareerPath` response model to include validation result
  - [ ] Add validation result to the first skill's code snippet
  - [ ] Format validation details for display
- [ ] **Task 4 (AC: 6):** Add error handling for Daytona integration.
  - [ ] Handle Daytona API authentication failures
  - [ ] Handle workspace creation failures
  - [ ] Handle execution timeouts (>30 seconds)
  - [ ] Handle network errors and API unavailability
  - [ ] Provide fallback behavior if validation fails
  - [ ] Log all errors appropriately

## Dev Notes

### Tech Stack

- **Backend Language:** Python 3.11+ [Source: architecture.md#tech-stack]
- **Backend Framework:** FastAPI [Source: architecture.md#tech-stack]
- **Code Validation:** Daytona (Safe Runtime) [Source: prd.md#technical-specifications]

### Daytona Requirements

From PRD S6:

> "As the AI Agent, I can send the generated code snippet to a secure sandbox for validation to prove the code is functional and safe. Daytona (Safe Runtime): Execute the code snippet and return a simple 'Success/Failure' status."

**Key Requirements:**

- Execute code in a **secure, isolated sandbox** - no access to host system
- Support multiple programming languages (Python, JavaScript, etc.)
- Return execution status: Success or Failure
- Capture execution output (stdout/stderr)
- Implement reasonable timeout (30 seconds max)
- Clean up resources after execution

**User Value:**

- Provides confidence that the generated code actually works
- Demonstrates code safety through sandboxed execution
- Validates that the learning path is actionable
- Shows real-world execution results

### Daytona API Integration

**API Endpoint:** `https://api.daytona.io/v1` (example - verify actual endpoint)

**Authentication:**

- API Key-based authentication
- Store API key in environment variable: `DAYTONA_API_KEY`

**Workflow:**

1. Create a new workspace/sandbox
2. Upload the code snippet
3. Execute the code
4. Capture output and status
5. Clean up the workspace

**Example API Calls:**

```python
# 1. Create workspace
POST /workspaces
{
  "name": "code-validation-{uuid}",
  "runtime": "python:3.11",  # or "node:18" for JavaScript
  "timeout": 30
}

# 2. Execute code
POST /workspaces/{workspace_id}/execute
{
  "code": "print('Hello, World!')",
  "entrypoint": "main.py"
}

# 3. Get execution result
GET /workspaces/{workspace_id}/status

# 4. Delete workspace
DELETE /workspaces/{workspace_id}
```

### Language-to-Runtime Mapping

Map programming languages to Daytona runtime environments:

```python
LANGUAGE_RUNTIME_MAP = {
    "python": "python:3.11",
    "javascript": "node:18",
    "typescript": "node:18",
    "java": "java:17",
    "go": "golang:1.21",
    "sql": "postgres:15",  # For SQL validation
}
```

### Validation Result Model

```python
class CodeValidation(BaseModel):
    skill: str  # The skill being demonstrated
    status: Literal["Success", "Failure"]  # Execution status
    output: str  # stdout from execution
    error: Optional[str] = None  # stderr if any
    execution_time: float  # Time in seconds
    details: str  # Human-readable summary

class CodeSnippet(BaseModel):
    code: str
    language: str
    description: str
    validation: Optional[CodeValidation] = None  # Populated after Daytona validation
```

### Data Flow

This is Step 11-12 in the core workflow:

1. Backend receives user input (Current Role, Target Role)
2. Backend queries Weaviate with Target Role (Story 1.2 - COMPLETED)
3. Weaviate returns relevant skill documents (Story 1.2 - COMPLETED)
4. Backend passes documents to FriendliAI for analysis (Story 1.3 - COMPLETED)
5. FriendliAI analyzes and returns top 3 skills (Story 1.3 - COMPLETED)
6. FriendliAI calls aci.dev tool for each skill (Story 1.4 - COMPLETED)
7. aci.dev executes `search_learning_content` and returns courses (Story 1.4 - COMPLETED)
8. Backend integrates course recommendations into response (Story 1.4 - COMPLETED)
9. Backend calls FriendliAI to generate code snippet for first skill (Story 1.5 - COMPLETED)
10. Backend integrates code snippet into response (Story 1.5 - COMPLETED)
11. **→ Backend sends code to Daytona for validation (THIS STORY)**
12. **→ Daytona executes code and returns validation result (THIS STORY)**
13. **→ Backend integrates validation result into response (THIS STORY)**
14. Backend will log everything to Comet (Next Story - 1.7)
    [Source: architecture.md#core-workflows]

### Previous Story Insights

From Story 1.5 (Code Snippet Generation):

- Code snippets are generated for the first skill only
- Code includes language metadata (python, javascript, etc.)
- Code is 5-10 lines, functional and runnable
- Code includes explanatory comments
- Security validation prevents dangerous patterns
  [Source: docs/stories/1.5.Implement-Code-Snippet-Generation.md]

### Integration Points

- **Input:** Receives code snippet and language from Story 1.5
- **Output:** Returns validation result to be added to the career path response
- **Next Step:** Comet logging (Story 1.7) will track the validation execution
- **User Experience:** Validation result will be displayed with the code snippet, showing execution output

### File Locations

- **Daytona Client:** Create new file `api/daytona_client.py` [Source: architecture.md#unified-project-structure]
- **Main Orchestrator:** Update `api/index.py` to call Daytona validation [Source: architecture.md#unified-project-structure]
- **Response Model:** Update in `api/index.py` to include validation result

### Daytona Client Implementation

Create `api/daytona_client.py`:

```python
import os
import uuid
import httpx
from typing import Dict, Any, Optional

DAYTONA_API_KEY = os.getenv("DAYTONA_API_KEY")
DAYTONA_BASE_URL = os.getenv("DAYTONA_BASE_URL", "https://api.daytona.io/v1")
EXECUTION_TIMEOUT = 30  # seconds

async def validate_code_with_daytona(
    code: str,
    language: str,
    skill: str
) -> Dict[str, Any]:
    """
    Validate code snippet using Daytona sandbox.

    Args:
        code: The code snippet to validate
        language: Programming language (python, javascript, etc.)
        skill: The skill being demonstrated

    Returns:
        Dictionary with validation results
    """
    # Implementation here
    pass
```

### Error Handling Strategy

**1. API Authentication Errors**

- Catch 401/403 responses
- Log error with details
- Return fallback validation result: `{"status": "Failure", "details": "Validation unavailable"}`

**2. Workspace Creation Failures**

- Retry once with exponential backoff
- If still fails, return fallback result
- Log error for debugging

**3. Execution Timeouts**

- Set timeout to 30 seconds
- If exceeded, terminate workspace
- Return: `{"status": "Failure", "details": "Execution timeout (>30s)"}`

**4. Network Errors**

- Catch connection errors
- Return fallback result
- Log error with stack trace

**5. Malformed Responses**

- Validate response structure
- If invalid, return fallback result
- Log warning

**Fallback Validation Result:**

```python
FALLBACK_VALIDATION = {
    "skill": skill,
    "status": "Failure",
    "output": "",
    "error": None,
    "execution_time": 0.0,
    "details": "Code validation unavailable - Daytona service error"
}
```

### Security Considerations

**1. Sandbox Isolation**

- Daytona provides isolated execution environment
- No access to host filesystem
- No network access from sandbox
- Resource limits enforced (CPU, memory, time)

**2. Code Validation Before Execution**

- Reuse security checks from Story 1.5
- Verify no prohibited patterns before sending to Daytona
- Double-layer security: validation + sandbox

**3. API Key Security**

- Store API key in environment variable
- Never log or expose API key
- Use HTTPS for all API calls

**4. Resource Cleanup**

- Always delete workspace after execution
- Implement cleanup in finally block
- Prevent resource leaks

**5. Rate Limiting**

- Respect Daytona API rate limits
- Implement exponential backoff for retries
- Cache validation results for identical code (optional)

### Performance Considerations

- **Execution Timeout:** 30 seconds maximum
- **Total Validation Time:** Should not exceed 45 seconds (including workspace setup/cleanup)
- **Async Execution:** Use async/await for non-blocking API calls
- **Parallel Execution:** Not needed for MVP (only validating one code snippet)

### Testing Requirements

- **Testing Strategy:** Manual testing for MVP, no automated tests required [Source: architecture.md#testing-strategy]

#### Test Categories

**1. Functional Tests (Core Functionality)**

- [ ] **TC-F1:** Validate successful Python code execution
  - Input: Simple Python code (e.g., `print("Hello")`)
  - Expected: Status = "Success", output contains "Hello"
  - Verify: Execution completes within timeout
- [ ] **TC-F2:** Validate successful JavaScript code execution
  - Input: Simple JavaScript code (e.g., `console.log("Hello")`)
  - Expected: Status = "Success", output contains "Hello"
  - Verify: Correct runtime selected
- [ ] **TC-F3:** Validate code with syntax errors
  - Input: Python code with syntax error
  - Expected: Status = "Failure", error message captured
  - Verify: Error details are informative
- [ ] **TC-F4:** Validate code with runtime errors
  - Input: Code that throws exception (e.g., division by zero)
  - Expected: Status = "Failure", error captured
  - Verify: Stack trace included in error
- [ ] **TC-F5:** Validate code with output
  - Input: Code that prints multiple lines
  - Expected: All output captured correctly
  - Verify: Output formatting preserved

**2. Integration Tests (System Integration)**

- [ ] **TC-I1:** End-to-end validation flow
  - Test: Generate code → Validate with Daytona → Return result
  - Expected: Complete flow works seamlessly
  - Verify: Validation result integrated into response
- [ ] **TC-I2:** Validation result in API response
  - Expected: `code_snippet.validation` field populated
  - Verify: All validation fields present (status, output, error, execution_time, details)
- [ ] **TC-I3:** Language-to-runtime mapping
  - Test: Various languages map to correct runtimes
  - Expected: Python → python:3.11, JavaScript → node:18, etc.
  - Verify: Correct runtime used for each language

**3. Error Handling Tests (Resilience)**

- [ ] **TC-E1:** Handle Daytona API authentication failure
  - Simulate: Invalid API key
  - Expected: Graceful fallback, error logged
  - Verify: System continues, returns fallback validation
- [ ] **TC-E2:** Handle workspace creation failure
  - Simulate: API returns 500 error
  - Expected: Retry once, then fallback
  - Verify: Error logged with details
- [ ] **TC-E3:** Handle execution timeout
  - Input: Code with infinite loop
  - Expected: Timeout after 30 seconds, workspace terminated
  - Verify: Status = "Failure", details mention timeout
- [ ] **TC-E4:** Handle network errors
  - Simulate: Network connection failure
  - Expected: Graceful fallback, error logged
  - Verify: User still receives response
- [ ] **TC-E5:** Handle malformed API response
  - Simulate: Invalid JSON response
  - Expected: Validation catches issue, uses fallback
  - Verify: System doesn't crash

**4. Performance Tests (Speed & Efficiency)**

- [ ] **TC-P1:** Validation completes within time limit
  - Test: Simple code validation
  - Expected: Total time < 45 seconds
  - Verify: Includes workspace setup, execution, cleanup
- [ ] **TC-P2:** Workspace cleanup is reliable
  - Test: Multiple validations in sequence
  - Expected: All workspaces cleaned up
  - Verify: No resource leaks
- [ ] **TC-P3:** Async execution is non-blocking
  - Test: Validation doesn't block other operations
  - Expected: API remains responsive during validation
  - Verify: Other requests can be processed

**5. Security Tests (Sandbox Safety)**

- [ ] **TC-S1:** Code cannot access host filesystem
  - Input: Code attempting file operations
  - Expected: Operation fails or is blocked
  - Verify: No files created on host
- [ ] **TC-S2:** Code cannot make network requests
  - Input: Code attempting HTTP requests
  - Expected: Network access blocked
  - Verify: Request fails in sandbox
- [ ] **TC-S3:** Resource limits are enforced
  - Input: Code consuming excessive memory
  - Expected: Execution terminated by resource limit
  - Verify: System remains stable
- [ ] **TC-S4:** API key is never exposed
  - Test: Check logs and responses
  - Expected: API key never appears in logs or responses
  - Verify: Secure credential handling

**6. User Experience Tests (Usability)**

- [ ] **TC-U1:** Validation result is informative
  - Verify: Success message is clear and encouraging
  - Verify: Failure message explains what went wrong
  - Test: Non-technical user can understand result
- [ ] **TC-U2:** Execution output is readable
  - Verify: Output formatting is preserved
  - Verify: Long output is truncated appropriately
  - Test: Output is displayed correctly in UI
- [ ] **TC-U3:** Execution time is displayed
  - Verify: Execution time is shown in human-readable format
  - Verify: Time is accurate (within 100ms)
- [ ] **TC-U4:** Error messages are helpful
  - Verify: Error messages suggest potential fixes
  - Verify: Stack traces are formatted for readability

#### Test Data Sets

**Common Code Snippets to Test:**

**Python:**

```python
# Success case
print("Hello, World!")

# Syntax error
print("Hello, World!"

# Runtime error
x = 1 / 0

# With output
for i in range(5):
    print(f"Number: {i}")
```

**JavaScript:**

```javascript
// Success case
console.log("Hello, World!");

// Syntax error
console.log("Hello, World!"

// Runtime error
throw new Error("Test error");

// With output
for (let i = 0; i < 5; i++) {
    console.log(`Number: ${i}`);
}
```

**Edge Cases:**

- Empty code string
- Very long code (>1000 lines)
- Code with special characters
- Code with infinite loop
- Code consuming excessive memory

#### Acceptance Testing Checklist

Before marking story as "Done", verify:

- [ ] All functional tests pass (5/5)
- [ ] All integration tests pass (3/3)
- [ ] All error handling tests pass (5/5)
- [ ] At least 80% of performance tests pass (minimum 2/3)
- [ ] All security tests pass (4/4)
- [ ] At least 75% of UX tests pass (minimum 3/4)
- [ ] Manual review confirms validation is reliable and secure
- [ ] Product Owner approves validation results and error handling

### Environment Variables

Add to `.env`:

```bash
# Daytona Configuration
DAYTONA_API_KEY=your_daytona_api_key_here
DAYTONA_BASE_URL=https://api.daytona.io/v1
DAYTONA_TIMEOUT=30
```

Add to `.env.example`:

```bash
# Daytona Configuration
DAYTONA_API_KEY=your_daytona_api_key_here
DAYTONA_BASE_URL=https://api.daytona.io/v1
DAYTONA_TIMEOUT=30
```

### Dependencies

Add to `api/requirements.txt`:

```
httpx>=0.24.0  # For async HTTP requests to Daytona API
```

### Example Validation Results

**Success Case:**

```json
{
  "skill": "Machine Learning",
  "status": "Success",
  "output": "Predicted score for 6 hours: 5.80\n",
  "error": null,
  "execution_time": 0.234,
  "details": "Code executed successfully in 0.23 seconds"
}
```

**Failure Case (Syntax Error):**

```json
{
  "skill": "Python",
  "status": "Failure",
  "output": "",
  "error": "SyntaxError: invalid syntax (line 3)",
  "execution_time": 0.012,
  "details": "Code execution failed: SyntaxError on line 3"
}
```

**Failure Case (Timeout):**

```json
{
  "skill": "Python",
  "status": "Failure",
  "output": "",
  "error": "Execution timeout",
  "execution_time": 30.0,
  "details": "Code execution exceeded 30 second timeout"
}
```

## Definition of Done

### Implementation Checklist

- [ ] `validate_code_with_daytona()` function implemented in `api/daytona_client.py`
- [ ] Daytona API authentication configured
- [ ] Workspace creation and cleanup implemented
- [ ] Code execution and result parsing implemented
- [ ] Language-to-runtime mapping implemented
- [ ] Response model updated with `CodeValidation` class
- [ ] Integration with main orchestrator in `api/index.py`
- [ ] Environment variables configured

### Testing Checklist

- [ ] All functional tests pass (5/5)
- [ ] All integration tests pass (3/3)
- [ ] All error handling tests pass (5/5)
- [ ] Performance tests pass (minimum 2/3)
- [ ] All security tests pass (4/4)
- [ ] UX tests pass (minimum 3/4)
- [ ] Test script created for manual testing
- [ ] Edge cases tested and documented

### Quality Checklist

- [ ] Code validation is reliable and consistent
- [ ] Execution results are accurate and informative
- [ ] Error messages are clear and helpful
- [ ] Validation completes within acceptable time (<45s)
- [ ] Resource cleanup is reliable (no leaks)
- [ ] Security is maintained (sandbox isolation)

### Integration Checklist

- [ ] Validation result integrated into API response
- [ ] Validation works for multiple programming languages
- [ ] Error handling provides graceful fallbacks
- [ ] Logging implemented for debugging
- [ ] Ready for Comet integration (Story 1.7)

### Security Checklist

- [ ] Sandbox isolation verified
- [ ] API key security confirmed
- [ ] Resource cleanup tested
- [ ] No sensitive data exposed in logs
- [ ] All security tests pass

### Documentation Checklist

- [ ] Function docstrings complete
- [ ] API integration documented
- [ ] Error handling strategy documented
- [ ] Testing procedures documented
- [ ] Known limitations documented

### Acceptance Checklist

- [ ] Product Owner review and approval
- [ ] Manual testing confirms validation reliability
- [ ] Demo prepared showing successful and failed validations
- [ ] Ready for integration with Story 1.7 (Comet logging)

## Change Log

| Date       | Version | Description                                | Author               |
| :--------- | :------ | :----------------------------------------- | :------------------- |
| 2025-10-02 | 1.0     | Initial draft                              | Scrum Master         |
| 2025-10-02 | 2.0     | Implementation completed - All tests ready | Full Stack Developer |
